using System;
using System.Collections.Generic;
using System.Linq;
using UnityEditor;
using UnityEngine;

namespace Nextzen.Unity
{
    public class SceneGraph
    {
        // Merged mesh data for each game object group
        private Dictionary<GameObject, MeshData> gameObjectMeshData;

        // The root game object
        private GameObject regionMap;

        // Group options for grouping
        private SceneGroupType groupOptions;

        // The leaf group of the hierarchy
        private SceneGroupType leafGroup;

        // The game object options (physics, static, ...)
        private GameObjectOptions gameObjectOptions;

        // The list of feature mesh generated by the tile task
        private List<FeatureMesh> features;

        public SceneGraph(GameObject regionMap, SceneGroupType groupOptions, GameObjectOptions gameObjectOptions, List<FeatureMesh> features)
        {
            this.gameObjectMeshData = new Dictionary<GameObject, MeshData>();
            this.regionMap = regionMap;
            this.groupOptions = groupOptions;
            this.gameObjectOptions = gameObjectOptions;
            this.features = features;
            this.leafGroup = groupOptions.GetLeaf();
        }

        private GameObject AddGameObjectGroup(SceneGroupType groupType, GameObject parentGameObject, FeatureMesh featureMesh)
        {
            GameObject gameObject = null;

            string name = featureMesh.GetName(groupType);

            // No name for this group in the feature, use the parent name
            if (name.Length == 0)
            {
                name = parentGameObject.name;
            }

            Transform transform = parentGameObject.transform.Find(name);

            if (transform == null)
            {
                // No children for this name, create a new game object
                gameObject = new GameObject(name);
                gameObject.transform.parent = parentGameObject.transform;
            }
            else
            {
                // Reuse the game object found the the group name in the hierarchy
                gameObject = transform.gameObject;
            }


            return gameObject;
        }

        private void MergeMeshData(GameObject gameObject, FeatureMesh featureMesh)
        {
            // Merge the mesh data from the feature for the game object
            if (gameObjectMeshData.ContainsKey(gameObject))
            {
                gameObjectMeshData[gameObject].Merge(featureMesh.Mesh);
            }
            else
            {
                MeshData data = new MeshData();
                data.Merge(featureMesh.Mesh);
                gameObjectMeshData.Add(gameObject, data);

                Debug.Log("Game Object Created: " + gameObject.name);
                Debug.Log("         Its Vertices: " + data.MeshDataVerticesToString());
                Debug.Log("         Its UVs: " + data.MeshDataUVsToString());
                Debug.Log("         Its Submeshes: " + data.MeshDataSubmeshesToString());
            }
        }

        public void Generate()
        {
            // 1. Generate the game object hierarchy in the scene graph
            if (groupOptions == SceneGroupType.Nothing)
            {
                // Merge every game object created to the 'root' element being the map region
                foreach (var featureMesh in features)
                {
                    MergeMeshData(regionMap, featureMesh);
                }
            }
            else
            {
                GameObject currentGroup;

                // Generate all game object with the appropriate hiarchy
                foreach (var featureMesh in features)
                {
                    currentGroup = regionMap;

                    foreach (SceneGroupType group in Enum.GetValues(typeof(SceneGroupType)))
                    {
                        // Exclude 'nothing' and 'everything' group
                        if (group == SceneGroupType.Nothing || group == SceneGroupType.Everything)
                        {
                            continue;
                        }

                        if (groupOptions.Includes(group))
                        {
                            // Use currentGroup as the parentGroup for the current generation
                            var parentGroup = currentGroup;
                            var newGroup = AddGameObjectGroup(group, parentGroup, featureMesh);

                            // Top down of the hierarchy, merge the game objects
                            if (group == leafGroup)
                            {
                                MergeMeshData(newGroup, featureMesh);
                            }

                            currentGroup = newGroup;
                        }
                    }
                }
            }

            // 2. Initialize game objects and associate their components (physics, rendering)
            foreach (var pair in gameObjectMeshData)
            {
                var meshData = pair.Value;
                var root = pair.Key;

                // Create one game object per mesh object 'bucket', each bucket is ensured to
                // have less that 65535 vertices (valid under Unity mesh max vertex count).
                for (int i = 0; i < meshData.Meshes.Count; ++i)
                {
                    var meshBucket = meshData.Meshes[i];
                    GameObject gameObject;

                    if (meshData.Meshes.Count > 1)
                    {
                        gameObject = new GameObject(root.name + "_Part" + i);
                        gameObject.transform.parent = root.transform;
                    }
                    else
                    {
                        gameObject = root.gameObject;
                    }

                    gameObject.isStatic = gameObjectOptions.IsStatic;

                    var mesh = new Mesh();

                    mesh.Clear();

                    mesh.SetVertices(meshBucket.Vertices);
                    mesh.SetUVs(0, meshBucket.UVs);
                    mesh.subMeshCount = meshBucket.Submeshes.Count;
                    for (int s = 0; s < meshBucket.Submeshes.Count; s++)
                    {
                        mesh.SetTriangles(meshBucket.Submeshes[s].Indices, s);

                    }
                    // Automatic Uvs Calculator
                    // meshBucket.setUvs();
                      Debug.Log("Total Mesh UVs is (Before) -> " + mesh.uv.Length);
                    //    Unwrapping.GenerateSecondaryUVSet(mesh);

                    mesh.RecalculateNormals();
                    mesh.RecalculateBounds();
                    MeshUtility.Optimize(mesh);

                    //------------------------------------------------------------------------------------------------------
                    //------------------------------------------------------------------------------------------------------
                    var varMesh = mesh;
                    var vertices = varMesh.vertices;
                    var uv = varMesh.uv;
                    var normals = varMesh.normals;
                    var szV = vertices.Length;
                    var newVerts = new Vector3[szV * 2];
                    var newUv = new Vector2[szV * 2];
                    var newNorms = new Vector3[szV * 2];
                    for (var j = 0; j < szV; j++)
                    {
                        // duplicate vertices and uvs:
                        newVerts[j] = newVerts[j + szV] = vertices[j];
                        newUv[j] = newUv[j + szV] = uv[j];
                        // copy the original normals...
                        newNorms[j] = normals[j];
                        // and revert the new ones
                        newNorms[j + szV] = -normals[j];
                    }
                    var triangles = varMesh.triangles;
                    var szT = triangles.Length;
                    var newTris = new int[szT * 2]; // double the triangles
                    for (var k = 0; k < szT; k += 3)
                    {
                        // copy the original triangle
                        newTris[k] = triangles[k];
                        newTris[k + 1] = triangles[k + 1];
                        newTris[k + 2] = triangles[k + 2];
                        // save the new reversed triangle
                        int j = k + szT;
                        newTris[j] = triangles[i] + szV;
                        newTris[j + 2] = triangles[i + 1] + szV;
                        newTris[j + 1] = triangles[i + 2] + szV;
                    }
                    varMesh.vertices = newVerts;
                    varMesh.uv = newUv;
                    varMesh.normals = newNorms;
                    varMesh.triangles = newTris; // assign triangles last!

                    mesh = varMesh;

                    //------------------------------------------------------------------------------------------------------
                    //------------------------------------------------------------------------------------------------------

                    Debug.Log("Total Mesh UVs is (After) -> " + mesh.uv.Length);

                    // Associate the mesh filter and mesh renderer components with this game object
                    var materials = meshBucket.Submeshes.Select(s => s.Material).ToArray();
                    var meshFilterComponent = gameObject.AddComponent<MeshFilter>();
                    var meshRendererComponent = gameObject.AddComponent<MeshRenderer>();
                    meshRendererComponent.materials = materials;
                    meshFilterComponent.mesh = mesh;


                    Mesh m = new Mesh();
                    m.Clear();
                    m.vertices = mesh.vertices;
                    m.triangles = mesh.triangles;
                    //m.uv = UvCalculator.CalculateUVs(m.vertices, 1);
                    Debug.Log("Before -> " + m.uv.Length);
                    Unwrapping.GenerateSecondaryUVSet(m);

                    m.RecalculateNormals();
                    m.RecalculateBounds();
                    MeshUtility.Optimize(m);

                    //    meshFilterComponent.mesh.Clear();

                    //    meshFilterComponent.mesh = m;



                    if (gameObjectOptions.GeneratePhysicMeshCollider)
                    {
                        var meshColliderComponent = gameObject.AddComponent<MeshCollider>();
                        meshColliderComponent.material = gameObjectOptions.PhysicMaterial;
                        meshColliderComponent.sharedMesh = mesh;
                        //        meshColliderComponent.sharedMesh = m;
                    }
                }
            }
        }
    }
}